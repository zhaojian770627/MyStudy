options {  JAVA_UNICODE_ESCAPE = true;}PARSER_BEGIN(MiniJavaParser)  package javacc.b;    public class MiniJavaParser {}PARSER_END(MiniJavaParser)SKIP : /* WHITE SPACE */{  " "| "\t"| "\n"| "\r"| "\f"}SPECIAL_TOKEN : /* COMMENTS */{  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">}TOKEN : {  < LPAREN: "(" >| < RPAREN: ")" >| < LSQPAREN: "[" >| < RSQPAREN: "]" >| < LBRACE: "{" >| < RBRACE: "}" >| < SEMICOLON: ";" >| < DOT: "." >| < ASSIGN: "=" >| < LT: "<" >| < PLUS: "+" >| < MINUS: "-" >| < AND : "&&" >   | < NOT : "!" >   | < BOOLEAN: "boolean" >   | < CLASS: "class" >| < INTERFACE: "interface" >| < ELSE: "else" >| < EXTENDS: "extends" >| < FALSE: "false" >| < IF: "if" >| < WHILE: "while" >| < INTEGER: "int" >   | < LENGTH: "length" >| < MAIN: "main" >| < NEW: "new" >| < PUBLIC: "public" >| < RETURN: "return" >| < STATIC: "static" >| < STRING: "String" >| < THIS: "this" >| < TRUE: "true" >| < PRINT: "System.out.println" >| < VOID: "void" >         }TOKEN : /* LITERALS */{  < INTEGER_LITERAL: ( ["1"-"9"] (["0"-"9"])* | "0" ) >}TOKEN : /* IDENTIFIERS */{  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >|  < #LETTER:      [       "\u0024",       "\u0041"-"\u005a",       "\u005f",       "\u0061"-"\u007a",       "\u00c0"-"\u00d6",       "\u00d8"-"\u00f6",       "\u00f8"-"\u00ff",       "\u0100"-"\u1fff",       "\u3040"-"\u318f",       "\u3300"-"\u337f",       "\u3400"-"\u3d2d",       "\u4e00"-"\u9fff",       "\uf900"-"\ufaff"      ]  >|  < #DIGIT:      [       "\u0030"-"\u0039",       "\u0660"-"\u0669",       "\u06f0"-"\u06f9",       "\u0966"-"\u096f",       "\u09e6"-"\u09ef",       "\u0a66"-"\u0a6f",       "\u0ae6"-"\u0aef",       "\u0b66"-"\u0b6f",       "\u0be7"-"\u0bef",       "\u0c66"-"\u0c6f",       "\u0ce6"-"\u0cef",       "\u0d66"-"\u0d6f",       "\u0e50"-"\u0e59",       "\u0ed0"-"\u0ed9",       "\u1040"-"\u1049"      ]  >}/************************************ * The MiniJava Grammar Starts Here * ************************************/void Goal() :{}{  MainClass()  ( TypeDeclaration() )*  <EOF>}void MainClass() :{}{	"class" Identifier() "{" "public" "static" "void" "main" "(" "String"	"[" "]" Identifier() ")"  "{" Statement() "}" "}" }void TypeDeclaration():{}{  LOOKAHEAD(3)  ClassDeclaration()| ClassExtendsDeclaration()}void ClassDeclaration() :{}{  < CLASS >Identifier()<LBRACE >  ( VarDeclaration() )*  ( MethodDeclaration() )*  <RBRACE >}void ClassExtendsDeclaration() :{}{  < CLASS >Identifier()<EXTENDS >  Identifier()  <LBRACE >  ( VarDeclaration() )*  ( MethodDeclaration() )*  <RBRACE >}void MethodDeclaration() :{}{	< PUBLIC > Type() Identifier() <LPAREN> ( FormalParameterList())?<RPAREN>	 < LBRACE >  (LOOKAHEAD(2) VarDeclaration())* (Statement())* < RETURN > Expression() ";"< RBRACE >}void FormalParameterList() :{}{  FormalParameter() ( FormalParameterRest() )*}void FormalParameter() :{}{  Type() Identifier()}void FormalParameterRest() :{}{  "," FormalParameter()}void VarDeclaration() :  {}{   Type() Identifier() ";"      }void Type() :  {}{   LOOKAHEAD(2)    ArrayType()  | BooleanType()  | IntegerType()  | Identifier()}void IntegerType() :{}{  "int"}void BooleanType() :{}{  "boolean"}void ArrayType() :{}{  "int" "[" "]"}void Statement():{}{	Block()	|IfStatement()	|  LOOKAHEAD(2)  	AssignmentStatement()	| LOOKAHEAD(2)  	ArrayAssignmentStatement() 	|  	WhileStatement() 	|   	PrintStatement()}void IfStatement() :{}{  < IF > "(" Expression() ")"  Statement()  "else" Statement() }void  AssignmentStatement():{}{  Identifier() "="  Expression() ";"}void ArrayAssignmentStatement():{}{	Identifier() < LSQPAREN > Expression() < RSQPAREN > < ASSIGN> Expression()< SEMICOLON >}void WhileStatement():{}{  < WHILE > <LPAREN >Expression()< RPAREN > Statement()}void PrintStatement():{}{  < PRINT ><LPAREN >Expression()< RPAREN >< SEMICOLON >}void Expression() :{}{  LOOKAHEAD( PrimaryExpression() "&&" )  AndExpression()  |  LOOKAHEAD( PrimaryExpression() "<" )  CompareExpression()  |  LOOKAHEAD( PrimaryExpression() "+" )  PlusExpression()  |  LOOKAHEAD( PrimaryExpression() "-" )  MinusExpression()  |  LOOKAHEAD( PrimaryExpression() "*" )  TimesExpression()  |  LOOKAHEAD( PrimaryExpression() "[" )  ArrayLookup()  |  LOOKAHEAD( PrimaryExpression() "." "length" )  ArrayLength()  |  LOOKAHEAD( PrimaryExpression() "." Identifier() "(" )  MessageSend()  |   PrimaryExpression()}void AndExpression() :{} {  PrimaryExpression() "&&" PrimaryExpression()}void CompareExpression() :{} {  PrimaryExpression() "<" PrimaryExpression()}void PlusExpression() :{}{  PrimaryExpression() "+" PrimaryExpression()}void MinusExpression() :{}{  PrimaryExpression() "-" PrimaryExpression()}void TimesExpression() :{}{  PrimaryExpression() "*" PrimaryExpression()}void ArrayLookup() :{}{  PrimaryExpression() "[" PrimaryExpression() "]"}void ArrayLength() :{}{  PrimaryExpression() "." "length"}void MessageSend() :{}{  PrimaryExpression() "." Identifier()   "(" ( ExpressionList() )? ")"}void ExpressionList() :{}{  Expression() ( ExpressionRest() )*}void ExpressionRest() :{}{  "," Expression()}void Block() :{}{  "{" ( Statement() )* "}"}void Identifier() :{}{  <IDENTIFIER>}void PrimaryExpression() :{}{  IntegerLiteral()  |  TrueLiteral()|FalseLiteral()|   Identifier()  |  ThisExpression()  |  LOOKAHEAD(3)  ArrayAllocationExpression()|AllocationExpression()|LOOKAHEAD(2)NotExpression()|LOOKAHEAD(3)BracketExpression()}void IntegerLiteral():{}{  < INTEGER_LITERAL >}void TrueLiteral():{}{  < TRUE >}void FalseLiteral():{}{  < FALSE >}void ThisExpression():{}{  < THIS >}void ArrayAllocationExpression():{}{  < NEW > "int" < LSQPAREN >Expression()<RSQPAREN >}void AllocationExpression():{}{  < NEW > Identifier()< LPAREN > <RPAREN >}void NotExpression():{}{  < LPAREN ><NOT > Expression() <RPAREN >}void BracketExpression() :{}{  "(" Expression() ")"}